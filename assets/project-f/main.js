(()=>{"use strict";var t={740:(t,e,s)=>{s.r(e),s.d(e,{default:()=>r});const r='<html> <head> <meta charset="utf-8"/> <title>Project f</title> <script>let execution;async function interrupt(){if(void 0===execution)return;if(execution.interruptSet)return;execution.interruptSet=!0;const t=document.getElementById("result");t.value+="Interrupting...\\n";try{await execution.promise}catch(e){t.value+=String(e)}t.value+="Interrupted.\\n",execution=void 0}async function run(){for(;void 0!==execution;)await interrupt();const t=document.getElementById("code").value;document.cookie=`last=${btoa(t)};`;const e=document.getElementById("result");e.value="";const n={interruptSet:!1,print:t=>{e.value+=t},shouldInterrupt:function(){return this.interruptSet}};execution=n,execution.promise=document.compile(t,n).catch((t=>e.value+=new String(t)))}<\/script> <style>.row{display:flex;width:100vw;height:100vh}.column{flex:50%}body{overflow:hidden}*{background-color:#000;color:#fff}</style> </head> <body> <div class="row"> <div class="column"> <textarea id="code" style="width:95%;height:90%;resize:none"></textarea> <button onclick="run()">Run</button> <button onclick="interrupt()">Interrupt</button> </div> <div class="column"> <textarea id="result" disabled="disabled" style="width:95%;height:90%;resize:none"></textarea> </div> </div> </body> <script>(()=>{const t=document.cookie;if(!t.startsWith("last="))return;document.getElementById("code").value=atob(t.slice(5))})()<\/script> </html> '}},e={};function s(r){var n=e[r];if(void 0!==n)return n.exports;var i=e[r]={exports:{}};return t[r](i,i.exports,s),i.exports}s.d=(t,e)=>{for(var r in e)s.o(e,r)&&!s.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},s.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),s.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},(()=>{var t,e;!function(t){t.start="start",t.start_$0="start_$0",t.list="list",t.list_$0="list_$0",t.element_1="element_1",t.element_2="element_2",t.element_3="element_3",t.element_4="element_4",t.literal_1="literal_1",t.literal_2="literal_2",t.literal_3="literal_3",t.literal_4="literal_4",t.real="real",t.integer="integer",t.bool_1="bool_1",t.bool_2="bool_2",t.nll="nll",t.ident="ident",t._="_"}(t||(t={}));class r{constructor(e){this.kind=t.start,this.els=e,this.expr=(()=>this.els.map((t=>[t.pos,t.el.expr])))()}}class n{constructor(e,s){this.kind=t.list,this.pos=e,this.sub=s,this.expr=(()=>({kind:"app",pos:this.pos,exprs:this.sub.map((t=>t.els.expr))}))()}}class i{constructor(e){this.kind=t.element_1,this.e=e,this.expr=(()=>this.e.expr)()}}class l{constructor(e){this.kind=t.element_2,this.e=e,this.expr=(()=>this.e.expr)()}}class o{constructor(e){this.kind=t.element_3,this.e=e,this.expr=(()=>this.e.expr)()}}class a{constructor(e,s){this.kind=t.element_4,this.pos=e,this.e=s,this.expr=(()=>({kind:"app",pos:this.pos,exprs:Array.of({kind:"ident",pos:this.pos,name:"quote"},this.e.expr)}))()}}class h{constructor(e){this.kind=t.literal_1,this.e=e,this.expr=(()=>this.e.expr)()}}class c{constructor(e){this.kind=t.literal_2,this.e=e,this.expr=(()=>this.e.expr)()}}class u{constructor(e){this.kind=t.literal_3,this.e=e,this.expr=(()=>this.e.expr)()}}class p{constructor(e){this.kind=t.literal_4,this.e=e,this.expr=(()=>this.e.expr)()}}class m{constructor(e,s){this.kind=t.real,this.pos=e,this.str=s,this.expr=(()=>({kind:"literal",pos:this.pos,value:Number.parseFloat(this.str)}))()}}class g{constructor(e,s){this.kind=t.integer,this.pos=e,this.str=s,this.expr=(()=>({kind:"literal",pos:this.pos,value:BigInt(this.str)}))()}}class f{constructor(e){this.kind=t.bool_1,this.pos=e,this.expr=(()=>({kind:"literal",pos:this.pos,value:!0}))()}}class d{constructor(e){this.kind=t.bool_2,this.pos=e,this.expr=(()=>({kind:"literal",pos:this.pos,value:!1}))()}}class v{constructor(e){this.kind=t.nll,this.pos=e,this.expr=(()=>({kind:"literal",pos:this.pos,value:null}))()}}class x{constructor(e,s){this.kind=t.ident,this.pos=e,this.str=s,this.expr=(()=>({kind:"ident",pos:this.pos,name:this.str}))()}}class k{constructor(t){this.negating=!1,this.memoSafe=!0,this.pos={overallPos:0,line:1,offset:0},this.input=t}reset(t){this.pos=t}finished(){return this.pos.overallPos===this.input.length}clearMemos(){}matchstart(t,e){return this.run(t,(()=>{let s,n=null;return null!==this.match_(t+1,e)&&null!==(s=this.loop((()=>this.matchstart_$0(t+1,e)),0,-1))&&null!==this.match_(t+1,e)&&(n=new r(s)),n}))}matchstart_$0(e,s){return this.run(e,(()=>{let r,n,i=null;return null!==(r=this.mark())&&null!==(n=this.matchelement(e+1,s))&&null!==this.match_(e+1,s)&&(i={kind:t.start_$0,pos:r,el:n}),i}))}matchlist(t,e){return this.run(t,(()=>{let s,r,i=null;return null!==this.match_(t+1,e)&&null!==(s=this.mark())&&null!==this.regexAccept(String.raw`(?:\()`,"",t+1,e)&&null!==this.match_(t+1,e)&&null!==(r=this.loop((()=>this.matchlist_$0(t+1,e)),0,-1))&&null!==this.match_(t+1,e)&&null!==this.regexAccept(String.raw`(?:\))`,"",t+1,e)&&null!==this.match_(t+1,e)&&(i=new n(s,r)),i}))}matchlist_$0(e,s){return this.run(e,(()=>{let r,n=null;return null!==(r=this.matchelement(e+1,s))&&null!==this.match_(e+1,s)&&(n={kind:t.list_$0,els:r}),n}))}matchelement(t,e){return this.choice([()=>this.matchelement_1(t+1,e),()=>this.matchelement_2(t+1,e),()=>this.matchelement_3(t+1,e),()=>this.matchelement_4(t+1,e)])}matchelement_1(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchlist(t+1,e))&&(r=new i(s)),r}))}matchelement_2(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchliteral(t+1,e))&&(r=new l(s)),r}))}matchelement_3(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchident(t+1,e))&&(r=new o(s)),r}))}matchelement_4(t,e){return this.run(t,(()=>{let s,r,n=null;return null!==(s=this.mark())&&null!==this.regexAccept(String.raw`(?:\')`,"",t+1,e)&&null!==this.match_(t+1,e)&&null!==(r=this.matchelement(t+1,e))&&(n=new a(s,r)),n}))}matchliteral(t,e){return this.choice([()=>this.matchliteral_1(t+1,e),()=>this.matchliteral_2(t+1,e),()=>this.matchliteral_3(t+1,e),()=>this.matchliteral_4(t+1,e)])}matchliteral_1(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchinteger(t+1,e))&&(r=new h(s)),r}))}matchliteral_2(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchreal(t+1,e))&&(r=new c(s)),r}))}matchliteral_3(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchbool(t+1,e))&&(r=new u(s)),r}))}matchliteral_4(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.matchnll(t+1,e))&&(r=new p(s)),r}))}matchreal(t,e){return this.run(t,(()=>{let s,r,n=null;return null!==(s=this.mark())&&null!==(r=this.regexAccept(String.raw`(?:[\-+]?[0-9]+\.[0-9]+)`,"",t+1,e))&&(n=new m(s,r)),n}))}matchinteger(t,e){return this.run(t,(()=>{let s,r,n=null;return null!==(s=this.mark())&&null!==(r=this.regexAccept(String.raw`(?:[\-+]?[0-9]+)`,"",t+1,e))&&null!==this.negate((()=>this.regexAccept(String.raw`(?:\.)`,"",t+1,e)))&&(n=new g(s,r)),n}))}matchbool(t,e){return this.choice([()=>this.matchbool_1(t+1,e),()=>this.matchbool_2(t+1,e)])}matchbool_1(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.mark())&&null!==this.regexAccept(String.raw`(?:true\b)`,"",t+1,e)&&(r=new f(s)),r}))}matchbool_2(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.mark())&&null!==this.regexAccept(String.raw`(?:false\b)`,"",t+1,e)&&(r=new d(s)),r}))}matchnll(t,e){return this.run(t,(()=>{let s,r=null;return null!==(s=this.mark())&&null!==this.regexAccept(String.raw`(?:null\b)`,"",t+1,e)&&(r=new v(s)),r}))}matchident(t,e){return this.run(t,(()=>{let s,r,n=null;return null!==(s=this.mark())&&null!==(r=this.regexAccept(String.raw`(?:[a-zA-Z][a-zA-Z0-9]*)`,"",t+1,e))&&(n=new x(s,r)),n}))}match_(t,e){return this.regexAccept(String.raw`(?:[\s\n]*)`,"",t+1,e)}test(){const t=this.mark(),e=null!==this.matchstart(0);return this.reset(t),e}parse(){const t=this.mark(),e=this.matchstart(0);if(e)return{ast:e,errs:[]};this.reset(t);const s=new S;this.clearMemos(),this.matchstart(0,s);const r=s.getErr();return{ast:e,errs:null!==r?[r]:[]}}mark(){return this.pos}loopPlus(t){return this.loop(t,1,-1)}loop(t,e,s){const r=this.mark(),n=[];for(;-1===s||n.length<s;){const e=this.mark(),s=t();if(null===s||this.pos.overallPos===e.overallPos)break;n.push(s)}return n.length>=e?n:(this.reset(r),null)}run(t,e){const s=this.mark(),r=e();return null!==r?r:(this.reset(s),null)}choice(t){for(const e of t){const t=e();if(null!==t)return t}return null}regexAccept(t,e,s,r){return this.run(s,(()=>{const s=new RegExp(t,"y"+e),n=this.mark();s.lastIndex=n.overallPos;const i=this.tryConsume(s);return r&&r.record(n,i,{kind:"RegexMatch",literal:t.substring(3,t.length-1),negated:this.negating}),i}))}tryConsume(t){const e=t.exec(this.input);if(e){let s=0,r=-1;for(let t=0;t<e[0].length;++t)"\n"===e[0][t]&&(++s,r=t);return this.pos={overallPos:t.lastIndex,line:this.pos.line+s,offset:-1===r?this.pos.offset+e[0].length:e[0].length-r-1},e[0]}return null}noConsume(t){const e=this.mark(),s=t();return this.reset(e),s}negate(t){const e=this.mark(),s=this.negating;this.negating=!s;const r=t();return this.negating=s,this.reset(e),null===r||null}memoise(t,e){const s=this.mark(),r=e.get(s.overallPos);if(this.memoSafe&&void 0!==r)return this.reset(r[1]),r[0];const n=t();return this.memoSafe&&e.set(s.overallPos,[n,this.mark()]),n}}class b{constructor(t,e){this.pos=t,this.expmatches=[...e]}toString(){return`Syntax Error at line ${this.pos.line}:${this.pos.offset}. Expected one of ${this.expmatches.map((t=>"EOF"===t.kind?" EOF":` ${t.negated?"not ":""}'${t.literal}'`))}`}}class S{constructor(){this.mxpos={overallPos:-1,line:-1,offset:-1},this.regexset=new Set,this.pmatches=[]}record(t,e,s){null===e!==s.negated&&(t.overallPos>this.mxpos.overallPos&&(this.mxpos=t,this.pmatches=[],this.regexset.clear()),this.mxpos.overallPos===t.overallPos&&("RegexMatch"===s.kind?(this.regexset.has(s.literal)||this.pmatches.push(s),this.regexset.add(s.literal)):this.pmatches.push(s)))}getErr(){return-1!==this.mxpos.overallPos?new b(this.mxpos,this.pmatches):null}}class w{}class y extends w{constructor(t,e="<runtime>"){super(),this.fn=t,this.name=e}toString(){return this.name}}function _(t){return JSON.stringify(t,((t,e)=>"bigint"==typeof e?`int:${e.toString()}`:e instanceof w?`<fn ${e.toString()}>`:e))}class E{constructor(t){this.vars=new Map,this.prev=void 0===t?this:t}get(t){let e=this;for(;;){if(e.vars.has(t))return e.vars.get(t);if(e.prev===e)break;e=e.prev}return null}set(t,e){let s=this;for(;;){if(s.vars.has(t))return void s.vars.set(t,e);if(s.prev===s)break;s=s.prev}this.vars.set(t,e)}}!function(t){t[t.REGULAR=0]="REGULAR",t[t.WHILE=1]="WHILE",t[t.SET=2]="SET",t[t.PROG=3]="PROG",t[t.RETURN=4]="RETURN",t[t.IF=5]="IF"}(e||(e={}));class ${constructor(t,e,s,r,n){this.ignoreAutoPush=!1,this.prevValues=-1,this.isWhile=!1,this.kind=t,this.lexEnv=e,this.pc=s,this.list=r,this.traceAlso=n}}class A extends w{constructor(t,e,s,r){super(),this.lexEnv=t,this.params=e,this.body=s,this.pos=r}toString(){return`<func ${JSON.stringify(this.pos)}>`}}class I{constructor(t){this.valuesStack=[],this.frames=[],this.result=null,this.exec=t,this.globalLexEnv=new E}fillBuiltins(){this.globalLexEnv.set("print",new y((t=>{for(const e of t)this.exec.print(`${_(e)}\n`);return null}),"print")),this.globalLexEnv.set("print-top-scope",new y((t=>{for(const e of t)null!==e&&this.exec.print(`${_(e)}\n`);return null}),"print-top-scope"));const t=(t,e)=>{this.globalLexEnv.set(t,new y((t=>(this.expectLen(t.length,2),typeof t[0]!=typeof t[1]&&this.error("wrong arg types"),e(t[0],t[1]))),t))},e=(t,e)=>{this.globalLexEnv.set(t,new y((t=>(this.expectLen(t.length,1),e(t[0]))),t))};t("plus",((t,e)=>t+e)),t("minus",((t,e)=>t-e)),t("times",((t,e)=>t*e)),t("divide",((t,e)=>t/e)),t("equal",((t,e)=>t===e)),t("nonequal",((t,e)=>t!==e)),t("less",((t,e)=>t<e)),t("lesseq",((t,e)=>t<=e)),t("greater",((t,e)=>t>e)),t("greatereq",((t,e)=>t>=e)),e("isint",(t=>"bigint"==typeof t)),e("isreal",(t=>"number"==typeof t)),e("isbool",(t=>"boolean"==typeof t)),e("isnull",(t=>null===t)),e("isatom",(t=>"string"==typeof t)),e("islist",(t=>t instanceof Array)),t("or",((t,e)=>"boolean"==typeof t&&"boolean"==typeof e?t&&e:t&e)),t("or",((t,e)=>"boolean"==typeof t&&"boolean"==typeof e?t||e:t|e)),t("xor",((t,e)=>t^e)),e("not",(t=>("boolean"!=typeof t&&this.error("expected bool"),!t))),this.globalLexEnv.set("eval",new y((t=>{this.expectLen(t.length,1),this.frames.pop(),this.putValueOnStack(t[0])}),"eval")),e("head",(t=>(t instanceof Array||this.error(`expected array, got ${_(t)}`),0===t.length&&this.error("accessing head of empty list"),t[0]))),e("tail",(t=>(t instanceof Array||this.error(`expected array, got ${_(t)}`),0===t.length&&this.error("accessing tail of empty list"),t.slice(1)))),e("isempty",(t=>(t instanceof Array||this.error(`expected array, got ${_(t)}`),0===t.length))),this.globalLexEnv.set("cons",new y((t=>{this.expectLen(t.length,2);const e=t[0],s=t[1];return s instanceof Array||this.error(`expected array, got ${_(s)}`),Array.of(e,...s)}),"cons")),this.globalLexEnv.set("concat",new y((t=>(t.every((t=>t instanceof Array))||this.error("can't concat non-arrays"),Array.of().concat(...t))),"concat"))}error(t){const e=this.frames.flatMap((t=>{const e=t.list,s=[];if(void 0!==e.posInfo&&s.push(e.posInfo),void 0!==t.traceAlso){const e=t.traceAlso.list.posInfo;void 0!==e&&s.push(e)}return s}));throw new Error(t+"; stack:"+e.map((t=>`\n\t${JSON.stringify(t)}`)).join(""))}asString(t){if("string"==typeof t)return t;this.error(`expected string, got ${_(t)}`)}expectLen(t,e){t!==e&&this.error(`invalid arguments length, got ${t}, expected ${e}`)}putValueOnStack(t,s){if(t instanceof Array){const r=0===this.frames.length?this.globalLexEnv:this.frames.at(-1).lexEnv,n=new $(e.REGULAR,r,0,t,s);this.frames.push(n),0===t.length&&this.error("empty list not allowed in this context");const i=t[0];if("string"!=typeof i)return;switch(i){case"setq":this.expectLen(t.length,3),this.asString(t[1]),n.pc=2,n.kind=e.SET;break;case"quote":this.expectLen(t.length,2),this.frames.pop(),this.valuesStack.push(t[1]);break;case"prog":n.kind=e.PROG,n.lexEnv=new E(n.lexEnv),n.list.length<2&&this.error("`prog` expects arguments, got none"),n.list[1]instanceof Array||this.error("expected list of variables");for(const t of n.list[1])n.lexEnv.vars.set(this.asString(t),null);this.valuesStack.push(null),n.pc=2;break;case"lambda":{n.list.length<2&&this.error("insufficient function body");const t=n.list[1];t instanceof Array||this.error("args must be a list"),t.every((t=>"string"==typeof t))||this.error("args must be a string");const e=n.list.slice(2);e.posInfo=n.list.posInfo,this.frames.pop();const s=new A(this.frames.at(-1).lexEnv,t,e,n.list.posInfo);this.valuesStack.push(s);break}case"func":{n.list.length<3&&this.error("not enough arguments for function"),this.frames.pop();const t=["lambda",n.list[2]].concat(n.list.splice(3));t.posInfo=n.list.posInfo;const e=["setq",n.list[1],t];e.posInfo=n.list.posInfo,this.putValueOnStack(e);break}case"return":this.expectLen(n.list.length,2),n.kind=e.RETURN,n.pc=1;break;case"while":n.list.length<3&&this.error("while: not enough arguments"),n.kind=e.WHILE,n.prevValues=this.valuesStack.length,n.pc=1,n.isWhile=!0,n.ignoreAutoPush=!0,this.valuesStack.push(null);break;case"cond":4!==n.list.length&&this.error("while: not enough arguments"),n.kind=e.IF,n.pc=1,n.ignoreAutoPush=!0;break;case"break":this.expectLen(n.list.length,1),this.returnTo(null,!0)}}else if("string"==typeof t){const e=this.frames.at(-1);this.valuesStack.push(e.lexEnv.get(t))}else this.valuesStack.push(t)}returnTo(t,e){for(let s=this.frames.length-1;s>=0;s--){const r=this.frames[s];if(r.prevValues>=0&&r.isWhile===e)return this.frames.length=s,this.valuesStack.length=r.prevValues,void this.valuesStack.push(t)}this.error("can't unroll stack")}step(){if(this.exec.shouldInterrupt())return;const t=this.frames.at(-1);if(t.pc!==t.list.length&&!t.ignoreAutoPush){const s=t.list[t.pc];return t.kind===e.PROG&&this.valuesStack.pop(),t.pc+=1,void this.putValueOnStack(s)}switch(t.kind){case e.PROG:this.frames.pop();break;case e.SET:this.frames.pop(),t.lexEnv.set(t.list[1],this.valuesStack.pop()),this.valuesStack.push(null);break;case e.REGULAR:{const s=this.valuesStack.at(-t.list.length);s instanceof w||this.error(`function expected, got ${_(s)}`);const r=this.valuesStack.slice(this.valuesStack.length-t.list.length+1);if(this.valuesStack.length-=t.list.length,s instanceof y){const t=s.fn(r);void 0!==t&&(this.frames.pop(),this.valuesStack.push(t))}else if(s instanceof A){s.params.length!==r.length&&this.error(`wrong arguments number got ${r.length}, expected ${s.params.length} for ${s.toString()}`);const t=this.frames.pop(),n=new E(s.lexEnv);for(let t=0;t<r.length;t++)n.vars.set(s.params[t],r[t]);const i=new $(e.PROG,n,0,s.body,t);i.prevValues=this.valuesStack.length,this.frames.push(i),this.valuesStack.push(null)}break}case e.RETURN:{const t=this.valuesStack.pop();this.returnTo(t,!1);break}case e.WHILE:if(1===t.pc)this.valuesStack.pop(),this.putValueOnStack(t.list[1]),t.pc=2;else{t.pc=1;const s=this.valuesStack.pop();if("boolean"!=typeof s&&this.error(`while condition is not boolean: ${_(s)}`),s){const s=new $(e.PROG,t.lexEnv,0,t.list.slice(2));this.frames.push(s),this.valuesStack.push(null)}else this.frames.pop(),this.valuesStack.push(null)}break;case e.IF:if(1===t.pc)this.putValueOnStack(t.list[1]),t.pc+=1;else{const e=this.valuesStack.pop();"boolean"!=typeof e&&this.error(`cond: expected boolean, got ${_(e)}`);const s=this.frames.pop(),r=e?t.list[2]:t.list[3];this.putValueOnStack(r,s)}}}async run(t){this.putValueOnStack(t);let e=0;for(;0!==this.frames.length;)if(this.step(),128==e++&&(e=0,await new Promise((t=>setTimeout(t,1))),this.exec.shouldInterrupt()))return null;if(1!==this.valuesStack.length)throw new Error(`invalid values stack size ${this.valuesStack.length}:\n${this.valuesStack.map(_).join("\n")}\n`);return this.valuesStack[0]}}const P=s(740);document.compile=async function(t,e){const s=new k(t),r=s.parse();if(r.errs.length>0)throw new Error(`parsing failed ${JSON.stringify(r.errs)}`);if(!s.finished())throw new Error(`parser not finished at ${JSON.stringify(s.mark())}`);const n=await async function(t){const e=t=>{switch(t.kind){case"ident":return t.name;case"literal":return t.value;case"app":{const s=t.exprs.map(e);return s.posInfo=t.pos,s}}};return t.map((t=>[e(t[1]),t[0]]))}(r.ast.expr),i=new I(e);i.fillBuiltins();const l=["prog",[]].concat(n.map((t=>["print-top-scope",t[0]])));return await i.run(l)},console.log(Object.keys(P)),document.write(P.default)})()})();